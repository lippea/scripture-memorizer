<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>经文默写</title>
  <style>
    body {
      margin: 0;
      padding: 24px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #f7f7f8;
      color: #1f2937;
    }
    .wrap {
      max-width: 760px;
      margin: 0 auto;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      padding: 18px;
    }
    h1 {
      margin: 0 0 12px;
      font-size: 22px;
    }
    .hint {
      margin: 10px 0 14px;
      padding: 12px;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      background: #fafafa;
      line-height: 1.6;
    }
    .ref-line {
      text-align: left;
      font-weight: 700;
      margin: 2px 0;
      color: #111827;
    }
    .ref-line.ref-fill {
      position: relative;
      min-height: 24px;
      padding-top: 2px;
      padding-bottom: 14px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-break: break-word;
      outline: none;
      cursor: text;
    }
    .ref-line.ref-fill::before {
      content: attr(data-placeholder);
      color: #9ca3af;
      opacity: 0.6;
      pointer-events: none;
      position: absolute;
      left: 0;
      top: 8px;
      right: 0;
      line-height: 1.8;
      white-space: pre-wrap;
    }
    .ref-line.ref-fill.has-input::before {
      opacity: 0.3;
    }
    .verse-compose {
      margin: 8px 0;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      gap: 0;
    }
    .prefix-lead {
      margin: 0;
      padding-right: 1px;
      color: #111827;
      line-height: 1.8;
      white-space: pre;
      word-break: keep-all;
      flex: 0 0 auto;
    }
    .verse-line {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      min-height: 56px;
      flex: 1 1 220px;
    }
    .verse-line.fill-mode {
      padding-bottom: 12px;
      line-height: 1.8;
      outline: none;
      cursor: text;
      position: relative;
    }
    .verse-line.fill-mode::before {
      content: attr(data-placeholder);
      color: #9ca3af;
      opacity: 0.6;
      pointer-events: none;
      position: absolute;
      left: 0;
      top: 6px;
      right: 0;
      white-space: pre-wrap;
      z-index: 0;
    }
    .verse-line.fill-mode.has-input::before {
      opacity: 0.35;
    }
    .verse-line.fill-mode:focus::before {
      opacity: 0.45;
    }
    .verse-line.checked {
      cursor: text;
    }
    .char-ok {
      color: #047857;
      font-weight: 600;
    }
    .char-bad {
      color: #b91c1c;
      font-weight: 600;
    }
    .char-extra {
      color: #b91c1c;
      text-decoration: line-through;
      text-decoration-thickness: 1.5px;
    }
    .char-missing {
      color: #b91c1c;
      font-weight: 600;
    }
    .row {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    button {
      border: 1px solid #d1d5db;
      border-radius: 8px;
      padding: 9px 13px;
      cursor: pointer;
      background: #2563eb;
      border-color: #2563eb;
      color: #ffffff;
    }
    button.secondary {
      border-color: #2563eb;
      color: #ffffff;
      background: #2563eb;
    }
    button:hover {
      background: #1d4ed8;
    }
    #result {
      margin-top: 12px;
      font-weight: 700;
    }
    .ok {
      color: #047857;
    }
    .bad {
      color: #b91c1c;
    }
    .note {
      margin-top: 10px;
      color: #6b7280;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>经文默写</h1>
    <div id="hint" class="hint">
      <div id="topRef" class="ref-line">加载中...</div>
      <div class="verse-compose">
        <span id="prefixLead" class="prefix-lead" hidden></span><div id="verseLine" class="verse-line"></div>
      </div>
      <div id="bottomRef" class="ref-line"></div>
    </div>
    <div class="row">
      <button id="checkBtn" type="button">检查</button>
      <button id="nextBtn" type="button">下一题</button>
    </div>
    <div id="result"></div>
    <div class="note">题型：随机只显示章节，或只显示经文前几个字（该模式需默写章节+经文）。</div>
  </div>

  <script>
    const els = {
      hint: document.getElementById("hint"),
      topRef: document.getElementById("topRef"),
      prefixLead: document.getElementById("prefixLead"),
      verseLine: document.getElementById("verseLine"),
      bottomRef: document.getElementById("bottomRef"),
      result: document.getElementById("result"),
      checkBtn: document.getElementById("checkBtn"),
      nextBtn: document.getElementById("nextBtn")
    };

    const state = {
      groups: [],
      verses: [],
      current: null,
      mode: "reference", // "reference" | "prefix"
      prefixText: ""
    };

    function normalize(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z0-9\u4e00-\u9fa5\s]/gi, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    function randomItem(list) {
      return list[Math.floor(Math.random() * list.length)];
    }

    function toGroupName(fileName) {
      return fileName
        .replace(/\.json$/i, "")
        .replace(/^verses[-_]?/i, "")
        .replace(/[-_]+/g, " ")
        .trim() || "未命名分组";
    }

    async function scanVerseGroupFiles() {
      const res = await fetch("./verses/");
      if (!res.ok) throw new Error("scan folder fail");
      const html = await res.text();
      const doc = new DOMParser().parseFromString(html, "text/html");
      const links = Array.from(doc.querySelectorAll("a"));
      const files = links
        .map((a) => decodeURIComponent(a.getAttribute("href") || "").trim())
        .filter((href) => href.toLowerCase().endsWith(".json"))
        .filter((href) => !href.includes("/"))
        .sort();

      if (!files.length) throw new Error("no json file in verses folder");

      return files.map((file) => ({
        name: toGroupName(file),
        file: `verses/${file}`
      }));
    }

    async function loadVersesFromFile(file) {
      const res = await fetch(`./${file}`);
      if (!res.ok) throw new Error(`load fail: ${file}`);
      const data = await res.json();
      if (!Array.isArray(data) || data.length === 0) {
        throw new Error(`empty verses: ${file}`);
      }
      const normalized = data
        .map((item) => {
          const reference = item.reference || item["出处"] || "";
          const text = item.text || item["内容"] || "";
          return {
            reference: String(reference).trim(),
            text: String(text).trim()
          };
        })
        .filter((item) => item.reference && item.text);

      if (normalized.length === 0) {
        throw new Error(`invalid verse format: ${file}`);
      }
      return normalized;
    }

    async function loadAllVerses(groups) {
      const all = [];
      for (const group of groups) {
        const items = await loadVersesFromFile(group.file);
        all.push(...items);
      }
      if (all.length === 0) throw new Error("no verses loaded");
      state.verses = all;
    }

    function toBlankLine(text) {
      // 按原文逐字符生成占位线，长度与待填内容一致
      return text
        .replace(/\r/g, "")
        .split("")
        .map((ch) => {
          if (ch === "\n") return "\n";
          if (/\s/.test(ch)) return "　";
          return "＿";
        })
        .join("");
    }

    function measurePlaceholderHeight(placeholderText) {
      const probe = document.createElement("div");
      const style = window.getComputedStyle(els.verseLine);
      probe.style.position = "absolute";
      probe.style.visibility = "hidden";
      probe.style.pointerEvents = "none";
      probe.style.left = "-9999px";
      probe.style.top = "-9999px";
      probe.style.whiteSpace = "pre-wrap";
      probe.style.wordBreak = "break-word";
      probe.style.font = style.font;
      probe.style.lineHeight = style.lineHeight;
      probe.style.width = `${els.verseLine.clientWidth || 640}px`;
      probe.textContent = placeholderText || "";
      document.body.appendChild(probe);
      const height = Math.ceil(probe.getBoundingClientRect().height);
      probe.remove();
      return height;
    }

    function syncFillLayoutHeight() {
      if (!els.verseLine.classList.contains("fill-mode")) {
        els.verseLine.style.minHeight = "56px";
        els.bottomRef.style.marginTop = "2px";
        return;
      }
      const placeholderText = els.verseLine.getAttribute("data-placeholder") || "";
      const placeholderHeight = measurePlaceholderHeight(placeholderText);
      // 高度固定由题目（下划线）决定，不随输入内容变化
      const targetHeight = Math.max(56, placeholderHeight + 8);
      els.verseLine.style.minHeight = `${targetHeight}px`;
      els.bottomRef.style.marginTop = "8px";
    }

    function syncFillUnderline() {
      const hasInput = normalize(els.verseLine.textContent).length > 0;
      els.verseLine.classList.toggle("has-input", hasInput);
      updateCheckButtonState();
    }

    function hasAnyUserInput() {
      if (!state.current) return false;
      if (state.mode === "reference") {
        return normalize(els.verseLine.textContent).length > 0;
      }
      const refInput = normalize(els.topRef.textContent).length > 0;
      const verseInput = normalize(els.verseLine.textContent).length > 0;
      return refInput || verseInput;
    }

    function updateCheckButtonState() {
      els.checkBtn.disabled = false;
      els.checkBtn.style.opacity = "1";
      els.checkBtn.style.cursor = "pointer";
    }

    function enableReferenceFillMode(referenceText) {
      const placeholder = toBlankLine(referenceText);
      els.topRef.classList.add("ref-fill");
      els.bottomRef.classList.add("ref-fill");
      els.topRef.setAttribute("contenteditable", "true");
      els.topRef.setAttribute("data-placeholder", placeholder);
      els.bottomRef.removeAttribute("contenteditable");
      els.bottomRef.setAttribute("data-placeholder", placeholder);
      els.topRef.textContent = "";
      els.bottomRef.textContent = "";
      els.topRef.classList.remove("has-input");
      els.bottomRef.classList.remove("has-input");
    }

    function disableReferenceFillMode(referenceText) {
      els.topRef.classList.remove("ref-fill", "has-input");
      els.bottomRef.classList.remove("ref-fill", "has-input");
      els.topRef.removeAttribute("contenteditable");
      els.topRef.removeAttribute("data-placeholder");
      els.bottomRef.removeAttribute("contenteditable");
      els.bottomRef.removeAttribute("data-placeholder");
      els.topRef.textContent = referenceText || "";
      els.bottomRef.textContent = referenceText || "";
    }

    function syncReferenceMirror() {
      if (state.mode !== "prefix") return;
      const text = els.topRef.textContent || "";
      const hasInput = normalize(text).length > 0;
      els.topRef.classList.toggle("has-input", hasInput);
      els.bottomRef.classList.toggle("has-input", hasInput);
      els.bottomRef.textContent = text;
      updateCheckButtonState();
    }

    function escapeHtml(text) {
      return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function charsEqual(a, b) {
      if (a === b) return true;
      if (!a || !b) return false;
      if (/\s/.test(a) && /\s/.test(b)) return true;
      return a.toLowerCase() === b.toLowerCase();
    }

    function isIgnoredPunctuation(ch) {
      if (!ch) return false;
      if (/\s/.test(ch)) return false;
      return !/[a-z0-9\u4e00-\u9fa5]/i.test(ch);
    }

    function toComparableChars(text) {
      return String(text || "")
        .replace(/\r/g, "")
        .split("")
        .filter((ch) => !isIgnoredPunctuation(ch));
    }

    function scoreAgainstExpected(user, expected) {
      const userChars = toComparableChars(user);
      const expectedChars = toComparableChars(expected);
      const maxLen = Math.max(userChars.length, expectedChars.length);
      if (maxLen === 0) return -1;
      let matches = 0;
      for (let i = 0; i < maxLen; i += 1) {
        const u = userChars[i] || "";
        const e = expectedChars[i] || "";
        if (charsEqual(u, e)) matches += 1;
      }
      return matches / maxLen;
    }

    function bestExpectedForUser(user, candidates) {
      let best = candidates[0] || "";
      let bestScore = -1;
      for (const candidate of candidates) {
        const score = scoreAgainstExpected(user, candidate);
        if (score > bestScore) {
          bestScore = score;
          best = candidate;
        }
      }
      return best;
    }

    function stripLeadingPromptText(userText, promptText) {
      const user = String(userText || "");
      const prompt = String(promptText || "");
      if (!prompt) return user;
      if (user.startsWith(prompt)) return user.slice(prompt.length);
      return user;
    }

    function renderComparedInput(user, expected) {
      const rawUser = String(user || "").replace(/\r/g, "");
      const rawExpected = String(expected || "").replace(/\r/g, "");
      const userChars = rawUser.split("").filter((ch) => !isIgnoredPunctuation(ch));
      const expectedChars = rawExpected.split("").filter((ch) => !isIgnoredPunctuation(ch));
      const m = userChars.length;
      const n = expectedChars.length;
      const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

      for (let i = m - 1; i >= 0; i -= 1) {
        for (let j = n - 1; j >= 0; j -= 1) {
          if (charsEqual(userChars[i], expectedChars[j])) {
            dp[i][j] = dp[i + 1][j + 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
          }
        }
      }

      function renderChar(ch, cls) {
        if (ch === "\n") return "<br>";
        if (cls === "char-neutral") return escapeHtml(ch);
        return `<span class="${cls}">${escapeHtml(ch)}</span>`;
      }

      const ops = [];
      let i = 0;
      let j = 0;

      while (i < m && j < n) {
        if (charsEqual(userChars[i], expectedChars[j])) {
          ops.push({ type: "ok", userChar: userChars[i], expectedChar: expectedChars[j] });
          i += 1;
          j += 1;
        } else if (dp[i + 1][j] >= dp[i][j + 1]) {
          ops.push({ type: "extra", userChar: userChars[i] });
          i += 1;
        } else {
          ops.push({ type: "missing", expectedChar: expectedChars[j] });
          j += 1;
        }
      }

      while (i < m) {
        ops.push({ type: "extra", userChar: userChars[i] });
        i += 1;
      }
      while (j < n) {
        ops.push({ type: "missing", expectedChar: expectedChars[j] });
        j += 1;
      }

      let html = "";
      let opIndex = 0;
      for (const expectedChar of rawExpected.split("")) {
        if (isIgnoredPunctuation(expectedChar)) {
          html += renderChar(expectedChar, "char-neutral");
          continue;
        }

        while (opIndex < ops.length && ops[opIndex].type === "extra") {
          html += renderChar(ops[opIndex].userChar, "char-extra");
          opIndex += 1;
        }

        const op = ops[opIndex];
        if (!op) {
          html += renderChar(expectedChar, "char-missing");
          continue;
        }

        if (op.type === "ok") {
          html += renderChar(op.userChar, "char-ok");
          opIndex += 1;
        } else if (op.type === "missing") {
          html += renderChar(op.expectedChar, "char-missing");
          opIndex += 1;
        } else {
          html += renderChar(expectedChar, "char-missing");
        }
      }

      while (opIndex < ops.length) {
        const op = ops[opIndex];
        if (op.type === "extra") {
          html += renderChar(op.userChar, "char-extra");
        }
        opIndex += 1;
      }

      return html;
    }

    function getExpectedCandidates() {
      if (!state.current) return [""];
      if (state.mode === "reference") return [state.current.text];
      return [state.current.text.slice(state.prefixText.length)];
    }

    function getCaretOffsetWithin(element) {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) return 0;
      const range = selection.getRangeAt(0);
      if (!element.contains(range.startContainer)) return 0;
      const preRange = range.cloneRange();
      preRange.selectNodeContents(element);
      preRange.setEnd(range.startContainer, range.startOffset);
      return preRange.toString().length;
    }

    function setCaretOffsetWithin(element, offset) {
      const selection = window.getSelection();
      if (!selection) return;

      const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
      let remaining = Math.max(0, offset);
      let node = walker.nextNode();
      let targetNode = null;
      let targetOffset = 0;

      while (node) {
        const len = node.textContent.length;
        if (remaining <= len) {
          targetNode = node;
          targetOffset = remaining;
          break;
        }
        remaining -= len;
        node = walker.nextNode();
      }

      if (!targetNode) {
        targetNode = element;
        targetOffset = element.childNodes.length;
      }

      const range = document.createRange();
      try {
        range.setStart(targetNode, targetOffset);
      } catch {
        range.selectNodeContents(element);
        range.collapse(false);
      }
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    function applyInlineDiffColoring() {
      if (!state.current) return;
      const rawUserInput = els.verseLine.textContent || "";
      const rawUser = state.mode === "prefix"
        ? stripLeadingPromptText(rawUserInput, state.prefixText)
        : rawUserInput;
      const caretOffset = getCaretOffsetWithin(els.verseLine);
      const expectedRaw = bestExpectedForUser(rawUser, getExpectedCandidates());
      els.verseLine.innerHTML = renderComparedInput(rawUser, expectedRaw);
      setCaretOffsetWithin(els.verseLine, caretOffset);
    }

    function applyReferenceDiffColoring() {
      if (!state.current || state.mode !== "prefix") return;
      const rawRef = els.topRef.textContent || "";
      const expected = state.current.reference || "";
      const html = renderComparedInput(rawRef, expected);
      els.topRef.innerHTML = html;
      els.bottomRef.innerHTML = html;
      const hasInput = normalize(rawRef).length > 0;
      els.topRef.classList.toggle("has-input", hasInput);
      els.bottomRef.classList.toggle("has-input", hasInput);
    }

    function newQuestion() {
      if (!state.verses.length) return;
      state.current = randomItem(state.verses);
      state.mode = Math.random() < 0.5 ? "reference" : "prefix";
      state.prefixText = "";

      const verse = state.current;
      const fullText = verse.text;
      const prefixLen = Math.max(4, Math.min(12, Math.floor(fullText.length * 0.18)));

      els.verseLine.classList.add("fill-mode");
      els.verseLine.removeAttribute("contenteditable");
      els.verseLine.setAttribute("contenteditable", "true");

      if (state.mode === "reference") {
        disableReferenceFillMode(verse.reference);
        els.prefixLead.hidden = true;
        els.prefixLead.textContent = "";
        els.verseLine.setAttribute("data-placeholder", toBlankLine(fullText));
        els.verseLine.textContent = "";
        els.verseLine.classList.remove("has-input");
      } else {
        state.prefixText = fullText.slice(0, prefixLen);
        const remainText = fullText.slice(prefixLen);
        enableReferenceFillMode(verse.reference);
        els.prefixLead.hidden = false;
        els.prefixLead.textContent = state.prefixText;
        const remainPlaceholder = toBlankLine(remainText);
        els.verseLine.setAttribute(
          "data-placeholder",
          remainPlaceholder
        );
        els.verseLine.textContent = "";
        els.verseLine.classList.remove("has-input");
        syncReferenceMirror();
      }
      syncFillLayoutHeight();
      els.result.textContent = "";
      els.result.className = "";
      updateCheckButtonState();
      if (state.mode === "prefix") {
        els.topRef.focus();
      } else {
        els.verseLine.focus();
      }
    }

    function isCorrect(inputText) {
      const verse = state.current;
      const rawInput = inputText ?? els.verseLine.textContent;
      const cleanedInput = state.mode === "prefix"
        ? stripLeadingPromptText(rawInput, state.prefixText)
        : rawInput;
      const user = normalize(cleanedInput);
      const full = normalize(verse.text);

      if (!user) return false;
      if (state.mode === "reference") return user === full;
      const refUser = normalize(els.topRef.textContent);
      const refExpected = normalize(verse.reference);
      if (refUser !== refExpected) return false;
      const remain = normalize(verse.text.slice(state.prefixText.length));
      return user === full || user === remain;
    }

    function checkAnswer() {
      if (!state.current) return;
      applyInlineDiffColoring();
      applyReferenceDiffColoring();
      els.result.textContent = "";
      els.result.className = "";
    }

    async function init() {
      try {
        // 优先扫描 verses/ 下的所有 json 文件；失败时回退到 groups.json
        try {
          state.groups = await scanVerseGroupFiles();
        } catch {
          const groupRes = await fetch("./groups.json");
          if (!groupRes.ok) throw new Error("groups load fail");
          state.groups = await groupRes.json();
        }

        if (!Array.isArray(state.groups) || state.groups.length === 0) {
          throw new Error("empty groups");
        }
        await loadAllVerses(state.groups);
        newQuestion();
      } catch (e) {
        els.topRef.textContent = "加载失败";
        els.prefixLead.hidden = true;
        els.prefixLead.textContent = "";
        els.verseLine.textContent = "请确认 verses/ 下有 json 文件，或提供 groups.json，并在当前目录启动本地服务访问页面。";
        els.bottomRef.textContent = "";
        console.error(e);
      }
    }

    els.checkBtn.addEventListener("click", checkAnswer);
    els.nextBtn.addEventListener("click", newQuestion);
    els.topRef.addEventListener("input", syncReferenceMirror);
    els.topRef.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        checkAnswer();
      }
    });
    els.verseLine.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        checkAnswer();
      }
    });
    els.verseLine.addEventListener("input", syncFillUnderline);
    window.addEventListener("resize", syncFillLayoutHeight);

    init();
  </script>
</body>
</html>
